# OD-10: Wire client pages to middleware stubs and validate submissions

## Notes

I'll analyze the repository to understand the structure and wire the client pages to middleware stubs with validation.

<read_file>
<path>.</path>
</read_file>

<read_file>
<path>src</path>
</read_file>

<read_file>
<path>src/pages</path>
</read_file>

<read_file>
<path>src/middleware</path>
</read_file>

<read_file>
<path>src/lib</path>
</read_file>

<read_file>
<path>src/pages/api</path>
</read_file>

<read_file>
<path>src/pages/api/onboarding</path>
</read_file>

<read_file>
<path>src/pages/api/onboarding/content.ts</path>
</read_file>

<read_file>
<path>src/pages/api/onboarding/submit.ts</path>
</read_file>

<read_file>
<path>src/pages/onboarding</path>
</read_file>

<read_file>
<path>src/pages/onboarding/[step].tsx</path>
</read_file>

<read_file>
<path>src/pages/onboarding/index.tsx</path>
</read_file>

<read_file>
<path>src/components</path>
</read_file>

<read_file>
<path>src/types</path>
</read_file>

<read_file>
<path>src/types/onboarding.ts</path>
</read_file>

<read_file>
<path>package.json</path>
</read_file>

Now let me check if there are any existing API client utilities:

<read_file>
<path>src/lib/api</path>
</read_file>

<read_file>
<path>src/utils</path>
</read_file>

Let me check the components directory for any form components:

<read_file>
<path>src/components/onboarding</path>
</read_file>

Now I'll create the necessary files to wire up the client pages to the middleware stubs:

<write_file>
<path>src/lib/api/onboarding.ts</path>
<content>/**
 * API client for onboarding endpoints
 */

import type { OnboardingContent, OnboardingSubmission } from '@/types/onboarding';

export interface OnboardingContentResponse {
  content: OnboardingContent;
}

export interface OnboardingSubmitResponse {
  success: boolean;
  nextStep?: string;
  message?: string;
}

/**
 * Fetch onboarding content for a specific step
 */
export async function fetchOnboardingContent(step: string): Promise<OnboardingContentResponse> {
  const response = await fetch(`/api/onboarding/content?step=${encodeURIComponent(step)}`);
  
  if (!response.ok) {
    const error = await response.json().catch(() => ({ message: 'Failed to fetch content' }));
    throw new Error(error.message || `HTTP ${response.status}`);
  }
  
  return response.json();
}

/**
 * Submit onboarding form data
 */
export async function submitOnboardingForm(
  step: string,
  data: Record<string, any>
): Promise<OnboardingSubmitResponse> {
  const submission: OnboardingSubmission = {
    step,
    data,
    timestamp: new Date().toISOString(),
  };

  const response = await fetch('/api/onboarding/submit', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify(submission),
  });

  if (!response.ok) {
    const error = await response.json().catch(() => ({ message: 'Failed to submit form' }));
    throw new Error(error.message || `HTTP ${response.status}`);
  }

  return response.json();
}
</content>
</write_file>

<write_file>
<path>src/lib/validation/onboarding.ts</path>
<content>/**
 * Client-side validation for onboarding forms
 */

import type { OnboardingQuestion } from '@/types/onboarding';

export interface ValidationError {
  field: string;
  message: string;
}

export interface ValidationResult {
  isValid: boolean;
  errors: ValidationError[];
}

/**
 * Validate a single field based on question configuration
 */
export function validateField(
  question: OnboardingQuestion,
  value: any
): ValidationError | null {
  const { id, required, validation } = question;

  // Check required fields
  if (required && (value === undefined || value === null || value === '')) {
    return {
      field: id,
      message: `${question.label || question.id} is required`,
    };
  }

  // Skip further validation if field is empty and not required
  if (!required && (value === undefined || value === null || value === '')) {
    return null;
  }

  // Type-specific validation
  switch (question.type) {
    case 'text':
    case 'textarea':
      if (typeof value !== 'string') {
        return { field: id, message: 'Must be a text value' };
      }
      if (validation?.minLength && value.length < validation.minLength) {
        return {
          field: id,
          message: `Must be at least ${validation.minLength} characters`,
        };
      }
      if (validation?.maxLength && value.length > validation.maxLength) {
        return {
          field: id,
          message: `Must be no more than ${validation.maxLength} characters`,
        };
      }
      if (validation?.pattern) {
        const regex = new RegExp(validation.pattern);
        if (!regex.test(value)) {
          return {
            field: id,
            message: validation.patternMessage || 'Invalid format',
          };
        }
      }
      break;

    case 'number':
      const num = Number(value);
      if (isNaN(num)) {
        return { field: id, message: 'Must be a valid number' };
      }
      if (validation?.min !== undefined && num < validation.min) {
        return { field: id, message: `Must be at least ${validation.min}` };
      }
      if (validation?.max !== undefined && num > validation.max) {
        return { field: id, message: `Must be no more than ${validation.max}` };
      }
      break;

    case 'email':
      if (typeof value !== 'string') {
        return { field: id, message: 'Must be a text value' };
      }
      const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
      if (!emailRegex.test(value)) {
        return { field: id, message: 'Must be a valid email address' };
      }
      break;

    case 'select':
    case 'radio':
      if (question.options && !question.options.some(opt => opt.value === value)) {
        return { field: id, message: 'Please select a valid option' };
      }
      break;

    case 'checkbox':
      if (!Array.isArray(value)) {
        return { field: id, message: 'Must be an array of values' };
      }
      if (question.options) {
        const validValues = question.options.map(opt => opt.value);
        const invalidValues = value.filter(v => !validValues.includes(v));
        if (invalidValues.length > 0) {
          return { field: id, message: 'Contains invalid selections' };
        }
      }
      break;

    case 'date':
      const date = new Date(value);
      if (isNaN(date.getTime())) {
        return { field: id, message: 'Must be a valid date' };
      }
      break;
  }

  return null;
}

/**
 * Validate all form data against questions
 */
export function validateForm(
  questions: OnboardingQuestion[],
  formData: Record<string, any>
): ValidationResult {
  const errors: ValidationError[] = [];

  for (const question of questions) {
    const value = formData[question.id];
    const error = validateField(question, value);
    if (error) {
      errors.push(error);
    }
  }

  return {
    isValid: errors.length === 0,
    errors,
  };
}
</content>
</write_file>

<write_file>
<path>src/hooks/useOnboarding.ts</path>
<content>/**
 * React hook for onboarding flow management
 */

import { useState, useEffect, useCallback } from 'react';
import { useRouter } from 'next/router';
import type { OnboardingContent } from '@/types/onboarding';
import { fetchOnboardingContent, submitOnboardingForm } from '@/lib/api/onboarding';
import { validateForm, type ValidationError } from '@/lib/validation/onboarding';

interface UseOnboardingResult {
  content: OnboardingContent | null;
  formData: Record<string, any>;
  errors: ValidationError[];
  isLoading: boolean;
  isSubmitting: boolean;
  error: string | null;
  setFieldValue: (field: string, value: any) => void;
  handleSubmit: () => Promise<void>;
  clearErrors: () => void;
}

export function useOnboarding(step: string): UseOnboardingResult {
  const router = useRouter();
  const [content, setContent] = useState<OnboardingContent | null>(null);
  const [formData, setFormData] = useState<Record<string, any>>({});
  const [errors, setErrors] = useState<ValidationError[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [error, setError] = useState<string | null>(null);

  // Load content on mount or step change
  useEffect(() => {
    let mounted = true;

    async function loadContent() {
      setIsLoading(true);
      setError(null);

      try {
        const response = await fetchOnboardingContent(step);
        if (mounted) {
          setContent(response.content);
          // Initialize form data with default values
          const initialData: Record<string, any> = {};
          response.content.questions.forEach(question => {
            if (question.defaultValue !== undefined) {
              initialData[question.id] = question.defaultValue;
            }
          });
          setFormData(initialData);
        }
      } catch (err) {
        if (mounted) {
          setError(err instanceof Error ? err.message : 'Failed to load content');
        }
      } finally {
        if (mounted) {
          setIsLoading(false);
        }
      }
    }

    loadContent();

    return () => {
      mounted = false;
    };
  }, [step]);

  const setFieldValue = useCallback((field: string, value: any) => {
    setFormData(prev => ({ ...prev, [field]: value }));
    // Clear field-specific errors when user updates the field
    setErrors(prev => prev.filter(err => err.field !== field));
  }, []);

  const clearErrors = useCallback(() => {
    setErrors([]);
  }, []);

  const handleSubmit = useCallback(async () => {
    if (!content) return;

    // Validate form
    const validation = validateForm(content.questions, formData);
    if (!validation.isValid) {
      setErrors(validation.errors);
      return;
    }

    setIsSubmitting(true);
    setError(null);

    try {
      const response = await submitOnboardingForm(step, formData);
      
      if (response.success) {
        // Navigate to next step or completion page
        if (response.nextStep) {
          await router.push(`/onboarding/${response.nextStep}`);
        } else {
          await router.push('/onboarding/complete');
        }
      } else {
        setError(response.message || 'Submission failed');
      }
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to submit form');
    } finally {
      setIsSubmitting(false);
    }
  }, [content, formData, step, router]);

  return {
    content,
    formData,
    errors,
    isLoading,
    isSubmitting,
    error,
    setFieldValue,
    handleSubmit,
    clearErrors,
  };
}
</content>
</write_file>

<write_file>
<path>src/pages/onboarding/[step].tsx</path>
<content>/**
 * Dynamic onboarding step page
 */

import { useRouter } from 'next/router';
import Head from 'next/head';
import { useOnboarding } from '@/hooks/useOnboarding';
import type { OnboardingQuestion } from '@/types/onboarding';

export default function OnboardingStepPage() {
  const router = useRouter();
  const { step } = router.query;
  const stepId = typeof step === 'string' ? step : 'welcome';

  const {
    content,
    formData,
    errors,
    isLoading,
    isSubmitting,
    error,
    setFieldValue,
    handleSubmit,
  } = useOnboarding(stepId);

  if (isLoading) {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <div className="text-center">
          <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600 mx-auto"></div>
          <p className="mt-4 text-gray-600">Loading...</p>
        </div>
      </div>
    );
  }

  if (error || !content) {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <div className="text-center max-w-md">
          <h1 className="text-2xl font-bold text-red-600 mb-4">Error</h1>
          <p className="text-gray-700 mb-6">{error || 'Failed to load content'}</p>
          <button
            onClick={() => router.push('/onboarding')}
            className="px-6 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700"
          >
            Return to Start
          </button>
        </div>
      </div>
    );
  }

  const getFieldError = (fieldId: string) => {
    return errors.find(err => err.field === fieldId)?.message;
  };

  const renderQuestion = (question: OnboardingQuestion) => {
    const fieldError = getFieldError(question.id);
    const value = formData[question.id];

    const baseInputClass = `w-full px-4 py-2 border rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent ${
      fieldError ? 'border-red-500' : 'border-gray-300'
    }`;

    switch (question.type) {
      case 'text':
      case 'email':
        return (
          <div key={question.id} className="mb-6">
            <label htmlFor={question.id} className="block text-sm font-medium text-gray-700 mb-2">
              {question.label}
              {question.required && <span className="text-red-500 ml-1">*</span>}
            </label>
            {question.description && (
              <p className="text-sm text-gray-500 mb-2">{question.description}</p>
            )}
            <input
              type={question.type}
              id={question.id}
              value={value || ''}
              onChange={(e) => setFieldValue(question.id, e.target.value)}
              placeholder={question.placeholder}
              className={base
